; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	e:\WORK\test\zlib-1.2.8\adler32.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__allrem:PROC
; Function compile flags: /Odtp
; File e:\work\test\zlib-1.2.8\adler32.c
;	COMDAT _adler32_combine_
_TEXT	SEGMENT
_sum2$ = -12						; size = 4
_rem$ = -8						; size = 4
_sum1$ = -4						; size = 4
_adler1$ = 8						; size = 4
_adler2$ = 12						; size = 4
_len2$ = 16						; size = 8
_adler32_combine_ PROC					; COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 141  :     unsigned long sum1;
; 142  :     unsigned long sum2;
; 143  :     unsigned rem;
; 144  : 
; 145  :     /* for negative len, return invalid adler32 as a clue for debugging */
; 146  :     if (len2 < 0)

  00006	83 7d 14 00	 cmp	 DWORD PTR _len2$[ebp+4], 0
  0000a	7f 10		 jg	 SHORT $LN5@adler32_co
  0000c	7c 06		 jl	 SHORT $LN8@adler32_co
  0000e	83 7d 10 00	 cmp	 DWORD PTR _len2$[ebp], 0
  00012	73 08		 jae	 SHORT $LN5@adler32_co
$LN8@adler32_co:

; 147  :         return 0xffffffffUL;

  00014	83 c8 ff	 or	 eax, -1
  00017	e9 dd 00 00 00	 jmp	 $LN6@adler32_co
$LN5@adler32_co:

; 148  : 
; 149  :     /* the derivation of this formula is left as an exercise for the reader */
; 150  :     MOD63(len2);                /* assumes len2 >= 0 */

  0001c	6a 00		 push	 0
  0001e	68 f1 ff 00 00	 push	 65521			; 0000fff1H
  00023	8b 45 14	 mov	 eax, DWORD PTR _len2$[ebp+4]
  00026	50		 push	 eax
  00027	8b 4d 10	 mov	 ecx, DWORD PTR _len2$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 __allrem
  00030	89 45 10	 mov	 DWORD PTR _len2$[ebp], eax
  00033	89 55 14	 mov	 DWORD PTR _len2$[ebp+4], edx

; 151  :     rem = (unsigned)len2;

  00036	8b 55 10	 mov	 edx, DWORD PTR _len2$[ebp]
  00039	89 55 f8	 mov	 DWORD PTR _rem$[ebp], edx

; 152  :     sum1 = adler1 & 0xffff;

  0003c	8b 45 08	 mov	 eax, DWORD PTR _adler1$[ebp]
  0003f	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00044	89 45 fc	 mov	 DWORD PTR _sum1$[ebp], eax

; 153  :     sum2 = rem * sum1;

  00047	8b 4d f8	 mov	 ecx, DWORD PTR _rem$[ebp]
  0004a	0f af 4d fc	 imul	 ecx, DWORD PTR _sum1$[ebp]
  0004e	89 4d f4	 mov	 DWORD PTR _sum2$[ebp], ecx

; 154  :     MOD(sum2);

  00051	8b 45 f4	 mov	 eax, DWORD PTR _sum2$[ebp]
  00054	33 d2		 xor	 edx, edx
  00056	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  0005b	f7 f1		 div	 ecx
  0005d	89 55 f4	 mov	 DWORD PTR _sum2$[ebp], edx

; 155  :     sum1 += (adler2 & 0xffff) + BASE - 1;

  00060	8b 55 0c	 mov	 edx, DWORD PTR _adler2$[ebp]
  00063	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00069	8b 45 fc	 mov	 eax, DWORD PTR _sum1$[ebp]
  0006c	8d 8c 10 f0 ff
	00 00		 lea	 ecx, DWORD PTR [eax+edx+65520]
  00073	89 4d fc	 mov	 DWORD PTR _sum1$[ebp], ecx

; 156  :     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;

  00076	8b 55 08	 mov	 edx, DWORD PTR _adler1$[ebp]
  00079	c1 ea 10	 shr	 edx, 16			; 00000010H
  0007c	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00082	8b 45 0c	 mov	 eax, DWORD PTR _adler2$[ebp]
  00085	c1 e8 10	 shr	 eax, 16			; 00000010H
  00088	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0008d	8d 8c 02 f1 ff
	00 00		 lea	 ecx, DWORD PTR [edx+eax+65521]
  00094	2b 4d f8	 sub	 ecx, DWORD PTR _rem$[ebp]
  00097	03 4d f4	 add	 ecx, DWORD PTR _sum2$[ebp]
  0009a	89 4d f4	 mov	 DWORD PTR _sum2$[ebp], ecx

; 157  :     if (sum1 >= BASE) sum1 -= BASE;

  0009d	81 7d fc f1 ff
	00 00		 cmp	 DWORD PTR _sum1$[ebp], 65521 ; 0000fff1H
  000a4	72 0c		 jb	 SHORT $LN4@adler32_co
  000a6	8b 55 fc	 mov	 edx, DWORD PTR _sum1$[ebp]
  000a9	81 ea f1 ff 00
	00		 sub	 edx, 65521		; 0000fff1H
  000af	89 55 fc	 mov	 DWORD PTR _sum1$[ebp], edx
$LN4@adler32_co:

; 158  :     if (sum1 >= BASE) sum1 -= BASE;

  000b2	81 7d fc f1 ff
	00 00		 cmp	 DWORD PTR _sum1$[ebp], 65521 ; 0000fff1H
  000b9	72 0b		 jb	 SHORT $LN3@adler32_co
  000bb	8b 45 fc	 mov	 eax, DWORD PTR _sum1$[ebp]
  000be	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  000c3	89 45 fc	 mov	 DWORD PTR _sum1$[ebp], eax
$LN3@adler32_co:

; 159  :     if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);

  000c6	81 7d f4 e2 ff
	01 00		 cmp	 DWORD PTR _sum2$[ebp], 131042 ; 0001ffe2H
  000cd	72 0c		 jb	 SHORT $LN2@adler32_co
  000cf	8b 4d f4	 mov	 ecx, DWORD PTR _sum2$[ebp]
  000d2	81 e9 e2 ff 01
	00		 sub	 ecx, 131042		; 0001ffe2H
  000d8	89 4d f4	 mov	 DWORD PTR _sum2$[ebp], ecx
$LN2@adler32_co:

; 160  :     if (sum2 >= BASE) sum2 -= BASE;

  000db	81 7d f4 f1 ff
	00 00		 cmp	 DWORD PTR _sum2$[ebp], 65521 ; 0000fff1H
  000e2	72 0c		 jb	 SHORT $LN1@adler32_co
  000e4	8b 55 f4	 mov	 edx, DWORD PTR _sum2$[ebp]
  000e7	81 ea f1 ff 00
	00		 sub	 edx, 65521		; 0000fff1H
  000ed	89 55 f4	 mov	 DWORD PTR _sum2$[ebp], edx
$LN1@adler32_co:

; 161  :     return sum1 | (sum2 << 16);

  000f0	8b 45 f4	 mov	 eax, DWORD PTR _sum2$[ebp]
  000f3	c1 e0 10	 shl	 eax, 16			; 00000010H
  000f6	0b 45 fc	 or	 eax, DWORD PTR _sum1$[ebp]
$LN6@adler32_co:

; 162  : }

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
_adler32_combine_ ENDP
_TEXT	ENDS
PUBLIC	_adler32@12
; Function compile flags: /Odtp
;	COMDAT _adler32@12
_TEXT	SEGMENT
_sum2$ = -8						; size = 4
_n$ = -4						; size = 4
_adler$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_adler32@12 PROC					; COMDAT

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 70   :     unsigned long sum2;
; 71   :     unsigned n;
; 72   : 
; 73   :     /* split Adler-32 into component sums */
; 74   :     sum2 = (adler >> 16) & 0xffff;

  00006	8b 45 08	 mov	 eax, DWORD PTR _adler$[ebp]
  00009	c1 e8 10	 shr	 eax, 16			; 00000010H
  0000c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00011	89 45 f8	 mov	 DWORD PTR _sum2$[ebp], eax

; 75   :     adler &= 0xffff;

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _adler$[ebp]
  00017	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001d	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx

; 76   : 
; 77   :     /* in case user likes doing a byte at a time, keep it fast */
; 78   :     if (len == 1) {

  00020	83 7d 10 01	 cmp	 DWORD PTR _len$[ebp], 1
  00024	75 4c		 jne	 SHORT $LN18@adler32

; 79   :         adler += buf[0];

  00026	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00029	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0002c	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  0002f	89 45 08	 mov	 DWORD PTR _adler$[ebp], eax

; 80   :         if (adler >= BASE)

  00032	81 7d 08 f1 ff
	00 00		 cmp	 DWORD PTR _adler$[ebp], 65521 ; 0000fff1H
  00039	72 0c		 jb	 SHORT $LN17@adler32

; 81   :             adler -= BASE;

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _adler$[ebp]
  0003e	81 e9 f1 ff 00
	00		 sub	 ecx, 65521		; 0000fff1H
  00044	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
$LN17@adler32:

; 82   :         sum2 += adler;

  00047	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0004a	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0004d	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx

; 83   :         if (sum2 >= BASE)

  00050	81 7d f8 f1 ff
	00 00		 cmp	 DWORD PTR _sum2$[ebp], 65521 ; 0000fff1H
  00057	72 0b		 jb	 SHORT $LN16@adler32

; 84   :             sum2 -= BASE;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  0005c	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  00061	89 45 f8	 mov	 DWORD PTR _sum2$[ebp], eax
$LN16@adler32:

; 85   :         return adler | (sum2 << 16);

  00064	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  00067	c1 e0 10	 shl	 eax, 16			; 00000010H
  0006a	0b 45 08	 or	 eax, DWORD PTR _adler$[ebp]
  0006d	e9 13 04 00 00	 jmp	 $LN19@adler32
$LN18@adler32:

; 86   :     }
; 87   : 
; 88   :     /* initial Adler-32 value (deferred check for len == 1 speed) */
; 89   :     if (buf == Z_NULL)

  00072	83 7d 0c 00	 cmp	 DWORD PTR _buf$[ebp], 0
  00076	75 0a		 jne	 SHORT $LN15@adler32

; 90   :         return 1L;

  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	e9 03 04 00 00	 jmp	 $LN19@adler32
$LN15@adler32:

; 91   : 
; 92   :     /* in case short lengths are provided, keep it somewhat fast */
; 93   :     if (len < 16) {

  00082	83 7d 10 10	 cmp	 DWORD PTR _len$[ebp], 16 ; 00000010H
  00086	73 62		 jae	 SHORT $LN10@adler32
$LN13@adler32:

; 94   :         while (len--) {

  00088	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  0008b	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  0008e	83 ea 01	 sub	 edx, 1
  00091	89 55 10	 mov	 DWORD PTR _len$[ebp], edx
  00094	85 c9		 test	 ecx, ecx
  00096	74 20		 je	 SHORT $LN12@adler32

; 95   :             adler += *buf++;

  00098	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0009b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0009e	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  000a1	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  000a4	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  000a7	83 c2 01	 add	 edx, 1
  000aa	89 55 0c	 mov	 DWORD PTR _buf$[ebp], edx

; 96   :             sum2 += adler;

  000ad	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  000b0	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  000b3	89 45 f8	 mov	 DWORD PTR _sum2$[ebp], eax

; 97   :         }

  000b6	eb d0		 jmp	 SHORT $LN13@adler32
$LN12@adler32:

; 98   :         if (adler >= BASE)

  000b8	81 7d 08 f1 ff
	00 00		 cmp	 DWORD PTR _adler$[ebp], 65521 ; 0000fff1H
  000bf	72 0c		 jb	 SHORT $LN11@adler32

; 99   :             adler -= BASE;

  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _adler$[ebp]
  000c4	81 e9 f1 ff 00
	00		 sub	 ecx, 65521		; 0000fff1H
  000ca	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
$LN11@adler32:

; 100  :         MOD28(sum2);            /* only added so many BASE's */

  000cd	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  000d0	33 d2		 xor	 edx, edx
  000d2	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  000d7	f7 f1		 div	 ecx
  000d9	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx

; 101  :         return adler | (sum2 << 16);

  000dc	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  000df	c1 e0 10	 shl	 eax, 16			; 00000010H
  000e2	0b 45 08	 or	 eax, DWORD PTR _adler$[ebp]
  000e5	e9 9b 03 00 00	 jmp	 $LN19@adler32
$LN10@adler32:

; 102  :     }
; 103  : 
; 104  :     /* do length NMAX blocks -- requires just one modulo operation */
; 105  :     while (len >= NMAX) {

  000ea	81 7d 10 b0 15
	00 00		 cmp	 DWORD PTR _len$[ebp], 5552 ; 000015b0H
  000f1	0f 82 ad 01 00
	00		 jb	 $LN9@adler32

; 106  :         len -= NMAX;

  000f7	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  000fa	81 ea b0 15 00
	00		 sub	 edx, 5552		; 000015b0H
  00100	89 55 10	 mov	 DWORD PTR _len$[ebp], edx

; 107  :         n = NMAX / 16;          /* NMAX is divisible by 16 */

  00103	c7 45 fc 5b 01
	00 00		 mov	 DWORD PTR _n$[ebp], 347	; 0000015bH
$LN8@adler32:

; 108  :         do {
; 109  :             DO16(buf);          /* 16 sums unrolled */

  0010a	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0010d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00110	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00113	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00116	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00119	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0011c	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0011f	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00122	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00126	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00129	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0012c	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0012f	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00132	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00135	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00138	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0013c	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0013f	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00142	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00145	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00148	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0014b	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0014e	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00152	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00155	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00158	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0015b	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0015e	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00161	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00164	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00168	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0016b	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0016e	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00171	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00174	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00177	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0017a	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0017e	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00181	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00184	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00187	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0018a	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0018d	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00190	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00194	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00197	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0019a	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0019d	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  001a0	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  001a3	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  001a6	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  001aa	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  001ad	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  001b0	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  001b3	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  001b6	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  001b9	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  001bc	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  001c0	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  001c3	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  001c6	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  001c9	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  001cc	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  001cf	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  001d2	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  001d6	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  001d9	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  001dc	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  001df	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  001e2	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  001e5	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  001e8	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  001ec	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  001ef	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  001f2	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  001f5	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  001f8	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  001fb	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  001fe	0f b6 48 0b	 movzx	 ecx, BYTE PTR [eax+11]
  00202	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00205	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00208	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0020b	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0020e	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00211	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00214	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  00218	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0021b	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0021e	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00221	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00224	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00227	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0022a	0f b6 48 0d	 movzx	 ecx, BYTE PTR [eax+13]
  0022e	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00231	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00234	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00237	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0023a	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0023d	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00240	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  00244	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00247	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0024a	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0024d	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00250	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00253	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00256	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  0025a	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0025d	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00260	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00263	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00266	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx

; 110  :             buf += 16;

  00269	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0026c	83 c0 10	 add	 eax, 16			; 00000010H
  0026f	89 45 0c	 mov	 DWORD PTR _buf$[ebp], eax

; 111  :         } while (--n);

  00272	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  00275	83 e9 01	 sub	 ecx, 1
  00278	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
  0027b	0f 85 89 fe ff
	ff		 jne	 $LN8@adler32

; 112  :         MOD(adler);

  00281	8b 45 08	 mov	 eax, DWORD PTR _adler$[ebp]
  00284	33 d2		 xor	 edx, edx
  00286	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  0028b	f7 f1		 div	 ecx
  0028d	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx

; 113  :         MOD(sum2);

  00290	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  00293	33 d2		 xor	 edx, edx
  00295	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  0029a	f7 f1		 div	 ecx
  0029c	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx

; 114  :     }

  0029f	e9 46 fe ff ff	 jmp	 $LN10@adler32
$LN9@adler32:

; 115  : 
; 116  :     /* do remaining bytes (less than NMAX, still just one modulo) */
; 117  :     if (len) {                  /* avoid modulos if none remaining */

  002a4	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  002a8	0f 84 ce 01 00
	00		 je	 $LN5@adler32
$LN4@adler32:

; 118  :         while (len >= 16) {

  002ae	83 7d 10 10	 cmp	 DWORD PTR _len$[ebp], 16 ; 00000010H
  002b2	0f 82 76 01 00
	00		 jb	 $LN2@adler32

; 119  :             len -= 16;

  002b8	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  002bb	83 ea 10	 sub	 edx, 16			; 00000010H
  002be	89 55 10	 mov	 DWORD PTR _len$[ebp], edx

; 120  :             DO16(buf);

  002c1	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  002c4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002c7	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  002ca	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  002cd	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  002d0	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  002d3	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  002d6	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  002d9	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  002dd	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  002e0	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  002e3	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  002e6	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  002e9	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  002ec	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  002ef	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  002f3	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  002f6	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  002f9	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  002fc	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  002ff	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00302	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00305	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00309	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0030c	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0030f	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00312	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00315	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00318	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0031b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0031f	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00322	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00325	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00328	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0032b	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0032e	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00331	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00335	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00338	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0033b	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0033e	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00341	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00344	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00347	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  0034b	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0034e	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00351	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00354	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00357	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0035a	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0035d	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  00361	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00364	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00367	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0036a	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0036d	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00370	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00373	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00377	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0037a	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0037d	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00380	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00383	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00386	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00389	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  0038d	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00390	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00393	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00396	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00399	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0039c	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0039f	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  003a3	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  003a6	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  003a9	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  003ac	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  003af	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  003b2	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  003b5	0f b6 48 0b	 movzx	 ecx, BYTE PTR [eax+11]
  003b9	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  003bc	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  003bf	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  003c2	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  003c5	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  003c8	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  003cb	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  003cf	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  003d2	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  003d5	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  003d8	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  003db	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  003de	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  003e1	0f b6 48 0d	 movzx	 ecx, BYTE PTR [eax+13]
  003e5	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  003e8	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  003eb	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  003ee	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  003f1	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  003f4	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  003f7	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  003fb	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  003fe	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00401	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00404	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00407	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0040a	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0040d	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  00411	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00414	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00417	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0041a	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0041d	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx

; 121  :             buf += 16;

  00420	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00423	83 c0 10	 add	 eax, 16			; 00000010H
  00426	89 45 0c	 mov	 DWORD PTR _buf$[ebp], eax

; 122  :         }

  00429	e9 80 fe ff ff	 jmp	 $LN4@adler32
$LN2@adler32:

; 123  :         while (len--) {

  0042e	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  00431	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00434	83 ea 01	 sub	 edx, 1
  00437	89 55 10	 mov	 DWORD PTR _len$[ebp], edx
  0043a	85 c9		 test	 ecx, ecx
  0043c	74 20		 je	 SHORT $LN1@adler32

; 124  :             adler += *buf++;

  0043e	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00441	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00444	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00447	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0044a	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  0044d	83 c2 01	 add	 edx, 1
  00450	89 55 0c	 mov	 DWORD PTR _buf$[ebp], edx

; 125  :             sum2 += adler;

  00453	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  00456	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  00459	89 45 f8	 mov	 DWORD PTR _sum2$[ebp], eax

; 126  :         }

  0045c	eb d0		 jmp	 SHORT $LN2@adler32
$LN1@adler32:

; 127  :         MOD(adler);

  0045e	8b 45 08	 mov	 eax, DWORD PTR _adler$[ebp]
  00461	33 d2		 xor	 edx, edx
  00463	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00468	f7 f1		 div	 ecx
  0046a	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx

; 128  :         MOD(sum2);

  0046d	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  00470	33 d2		 xor	 edx, edx
  00472	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00477	f7 f1		 div	 ecx
  00479	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
$LN5@adler32:

; 129  :     }
; 130  : 
; 131  :     /* return recombined sums */
; 132  :     return adler | (sum2 << 16);

  0047c	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  0047f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00482	0b 45 08	 or	 eax, DWORD PTR _adler$[ebp]
$LN19@adler32:

; 133  : }

  00485	8b e5		 mov	 esp, ebp
  00487	5d		 pop	 ebp
  00488	c2 0c 00	 ret	 12			; 0000000cH
_adler32@12 ENDP
PUBLIC	_adler32_combine@12
; Function compile flags: /Odtp
;	COMDAT _adler32_combine@12
_TEXT	SEGMENT
_adler1$ = 8						; size = 4
_adler2$ = 12						; size = 4
_len2$ = 16						; size = 4
_adler32_combine@12 PROC				; COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  :     return adler32_combine_(adler1, adler2, len2);

  00003	8b 45 10	 mov	 eax, DWORD PTR _len2$[ebp]
  00006	99		 cdq
  00007	52		 push	 edx
  00008	50		 push	 eax
  00009	8b 45 0c	 mov	 eax, DWORD PTR _adler2$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _adler1$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _adler32_combine_
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 171  : }

  00019	5d		 pop	 ebp
  0001a	c2 0c 00	 ret	 12			; 0000000cH
_adler32_combine@12 ENDP
END
