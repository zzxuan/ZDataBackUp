; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	e:\WORK\test\zlib-1.2.8\uncompr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_uncompress@16
; Function compile flags: /Odtp
; File e:\work\test\zlib-1.2.8\uncompr.c
;	COMDAT _uncompress@16
_TEXT	SEGMENT
_err$ = -60						; size = 4
_stream$ = -56						; size = 56
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_uncompress@16 PROC					; COMDAT

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 30   :     z_stream stream;
; 31   :     int err;
; 32   : 
; 33   :     stream.next_in = (z_const Bytef *)source;

  00006	8b 45 10	 mov	 eax, DWORD PTR _source$[ebp]
  00009	89 45 c8	 mov	 DWORD PTR _stream$[ebp], eax

; 34   :     stream.avail_in = (uInt)sourceLen;

  0000c	8b 4d 14	 mov	 ecx, DWORD PTR _sourceLen$[ebp]
  0000f	89 4d cc	 mov	 DWORD PTR _stream$[ebp+4], ecx

; 35   :     /* Check for source > 64K on 16-bit machine: */
; 36   :     if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;

  00012	8b 55 cc	 mov	 edx, DWORD PTR _stream$[ebp+4]
  00015	3b 55 14	 cmp	 edx, DWORD PTR _sourceLen$[ebp]
  00018	74 0a		 je	 SHORT $LN6@uncompress
  0001a	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  0001f	e9 9d 00 00 00	 jmp	 $LN7@uncompress
$LN6@uncompress:

; 37   : 
; 38   :     stream.next_out = dest;

  00024	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00027	89 45 d4	 mov	 DWORD PTR _stream$[ebp+12], eax

; 39   :     stream.avail_out = (uInt)*destLen;

  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _destLen$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	89 55 d8	 mov	 DWORD PTR _stream$[ebp+16], edx

; 40   :     if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _destLen$[ebp]
  00035	8b 4d d8	 mov	 ecx, DWORD PTR _stream$[ebp+16]
  00038	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0003a	74 07		 je	 SHORT $LN5@uncompress
  0003c	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00041	eb 7e		 jmp	 SHORT $LN7@uncompress
$LN5@uncompress:

; 41   : 
; 42   :     stream.zalloc = (alloc_func)0;

  00043	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+32], 0

; 43   :     stream.zfree = (free_func)0;

  0004a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+36], 0

; 44   : 
; 45   :     err = inflateInit(&stream);

  00051	6a 38		 push	 56			; 00000038H
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_05IAIEPMAK@1?42?48?$AA@
  00058	8d 55 c8	 lea	 edx, DWORD PTR _stream$[ebp]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _inflateInit_@12
  00061	89 45 c4	 mov	 DWORD PTR _err$[ebp], eax

; 46   :     if (err != Z_OK) return err;

  00064	83 7d c4 00	 cmp	 DWORD PTR _err$[ebp], 0
  00068	74 05		 je	 SHORT $LN4@uncompress
  0006a	8b 45 c4	 mov	 eax, DWORD PTR _err$[ebp]
  0006d	eb 52		 jmp	 SHORT $LN7@uncompress
$LN4@uncompress:

; 47   : 
; 48   :     err = inflate(&stream, Z_FINISH);

  0006f	6a 04		 push	 4
  00071	8d 45 c8	 lea	 eax, DWORD PTR _stream$[ebp]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 _inflate@8
  0007a	89 45 c4	 mov	 DWORD PTR _err$[ebp], eax

; 49   :     if (err != Z_STREAM_END) {

  0007d	83 7d c4 01	 cmp	 DWORD PTR _err$[ebp], 1
  00081	74 27		 je	 SHORT $LN3@uncompress

; 50   :         inflateEnd(&stream);

  00083	8d 4d c8	 lea	 ecx, DWORD PTR _stream$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 _inflateEnd@4

; 51   :         if (err == Z_NEED_DICT || (err == Z_BUF_ERROR && stream.avail_in == 0))

  0008c	83 7d c4 02	 cmp	 DWORD PTR _err$[ebp], 2
  00090	74 0c		 je	 SHORT $LN1@uncompress
  00092	83 7d c4 fb	 cmp	 DWORD PTR _err$[ebp], -5 ; fffffffbH
  00096	75 0d		 jne	 SHORT $LN2@uncompress
  00098	83 7d cc 00	 cmp	 DWORD PTR _stream$[ebp+4], 0
  0009c	75 07		 jne	 SHORT $LN2@uncompress
$LN1@uncompress:

; 52   :             return Z_DATA_ERROR;

  0009e	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000a3	eb 1c		 jmp	 SHORT $LN7@uncompress
$LN2@uncompress:

; 53   :         return err;

  000a5	8b 45 c4	 mov	 eax, DWORD PTR _err$[ebp]
  000a8	eb 17		 jmp	 SHORT $LN7@uncompress
$LN3@uncompress:

; 54   :     }
; 55   :     *destLen = stream.total_out;

  000aa	8b 55 0c	 mov	 edx, DWORD PTR _destLen$[ebp]
  000ad	8b 45 dc	 mov	 eax, DWORD PTR _stream$[ebp+20]
  000b0	89 02		 mov	 DWORD PTR [edx], eax

; 56   : 
; 57   :     err = inflateEnd(&stream);

  000b2	8d 4d c8	 lea	 ecx, DWORD PTR _stream$[ebp]
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 _inflateEnd@4
  000bb	89 45 c4	 mov	 DWORD PTR _err$[ebp], eax

; 58   :     return err;

  000be	8b 45 c4	 mov	 eax, DWORD PTR _err$[ebp]
$LN7@uncompress:

; 59   : }

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 10 00	 ret	 16			; 00000010H
_uncompress@16 ENDP
END
