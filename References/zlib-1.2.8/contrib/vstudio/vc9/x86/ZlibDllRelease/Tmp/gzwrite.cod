; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	e:\WORK\test\zlib-1.2.8\gzwrite.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ ; `string'
EXTRN	_vsnprintf:PROC
EXTRN	_write:PROC
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ DB 'internal er'
	DB	'ror: deflate stream corrupt', 00H		; `string'
; Function compile flags: /Odtp
; File e:\work\test\zlib-1.2.8\gzwrite.c
;	COMDAT _gz_init
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_init PROC						; COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 18   :     int ret;
; 19   :     z_streamp strm = &(state->strm);

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	83 c0 64	 add	 eax, 100		; 00000064H
  0000c	89 45 fc	 mov	 DWORD PTR _strm$[ebp], eax

; 20   : 
; 21   :     /* allocate input buffer */
; 22   :     state->in = (unsigned char *)malloc(state->want);

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00012	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 _malloc
  0001b	83 c4 04	 add	 esp, 4
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00021	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 23   :     if (state->in == NULL) {

  00024	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00027	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  0002b	75 1b		 jne	 SHORT $LN5@gz_init

; 24   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00032	6a fc		 push	 -4			; fffffffcH
  00034	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _gz_error
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25   :         return -1;

  00040	83 c8 ff	 or	 eax, -1
  00043	e9 11 01 00 00	 jmp	 $LN6@gz_init
$LN5@gz_init:

; 26   :     }
; 27   : 
; 28   :     /* only need output buffer and deflate state if compressing */
; 29   :     if (!state->direct) {

  00048	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0004b	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  0004f	0f 85 c9 00 00
	00		 jne	 $LN4@gz_init

; 30   :         /* allocate output buffer */
; 31   :         state->out = (unsigned char *)malloc(state->want);

  00055	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00058	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _malloc
  00061	83 c4 04	 add	 esp, 4
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00067	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 32   :         if (state->out == NULL) {

  0006a	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0006d	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  00071	75 2a		 jne	 SHORT $LN3@gz_init

; 33   :             free(state->in);

  00073	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00076	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 _free
  0007f	83 c4 04	 add	 esp, 4

; 34   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00087	6a fc		 push	 -4			; fffffffcH
  00089	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0008c	52		 push	 edx
  0008d	e8 00 00 00 00	 call	 _gz_error
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 35   :             return -1;

  00095	83 c8 ff	 or	 eax, -1
  00098	e9 bc 00 00 00	 jmp	 $LN6@gz_init
$LN3@gz_init:

; 36   :         }
; 37   : 
; 38   :         /* allocate deflate memory, set up for gzip compression */
; 39   :         strm->zalloc = Z_NULL;

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000a0	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 40   :         strm->zfree = Z_NULL;

  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000aa	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 41   :         strm->opaque = Z_NULL;

  000b1	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000b4	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], 0

; 42   :         ret = deflateInit2(strm, state->level, Z_DEFLATED,
; 43   :                            MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);

  000bb	6a 38		 push	 56			; 00000038H
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_05IAIEPMAK@1?42?48?$AA@
  000c2	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c5	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  000c8	51		 push	 ecx
  000c9	6a 08		 push	 8
  000cb	6a 1f		 push	 31			; 0000001fH
  000cd	6a 08		 push	 8
  000cf	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000d2	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  000d5	50		 push	 eax
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 _deflateInit2_@32
  000df	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 44   :         if (ret != Z_OK) {

  000e2	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000e6	74 36		 je	 SHORT $LN4@gz_init

; 45   :             free(state->out);

  000e8	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000eb	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _free
  000f4	83 c4 04	 add	 esp, 4

; 46   :             free(state->in);

  000f7	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000fa	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000fd	52		 push	 edx
  000fe	e8 00 00 00 00	 call	 _free
  00103	83 c4 04	 add	 esp, 4

; 47   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  0010b	6a fc		 push	 -4			; fffffffcH
  0010d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 _gz_error
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH

; 48   :             return -1;

  00119	83 c8 ff	 or	 eax, -1
  0011c	eb 3b		 jmp	 SHORT $LN6@gz_init
$LN4@gz_init:

; 49   :         }
; 50   :     }
; 51   : 
; 52   :     /* mark state as initialized */
; 53   :     state->size = state->want;

  0011e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00121	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00124	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00127	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 54   : 
; 55   :     /* initialize write buffer if compressing */
; 56   :     if (!state->direct) {

  0012a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0012d	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  00131	75 24		 jne	 SHORT $LN1@gz_init

; 57   :         strm->avail_out = state->size;

  00133	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  00136	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00139	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0013c	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 58   :         strm->next_out = state->out;

  0013f	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  00142	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00145	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00148	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 59   :         state->x.next = strm->next_out;

  0014b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0014e	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00151	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00154	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN1@gz_init:

; 60   :     }
; 61   :     return 0;

  00157	33 c0		 xor	 eax, eax
$LN6@gz_init:

; 62   : }

  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c3		 ret	 0
_gz_init ENDP
; Function compile flags: /Odtp
;	COMDAT _gz_comp
_TEXT	SEGMENT
_got$ = -16						; size = 4
_ret$ = -12						; size = 4
_strm$ = -8						; size = 4
_have$ = -4						; size = 4
_state$ = 8						; size = 4
_flush$ = 12						; size = 4
_gz_comp PROC						; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 74   :     int ret, got;
; 75   :     unsigned have;
; 76   :     z_streamp strm = &(state->strm);

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	83 c0 64	 add	 eax, 100		; 00000064H
  0000c	89 45 f8	 mov	 DWORD PTR _strm$[ebp], eax

; 77   : 
; 78   :     /* allocate memory if this is the first time through */
; 79   :     if (state->size == 0 && gz_init(state) == -1)

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00012	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00016	75 19		 jne	 SHORT $LN15@gz_comp
  00018	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 _gz_init
  00021	83 c4 04	 add	 esp, 4
  00024	83 f8 ff	 cmp	 eax, -1
  00027	75 08		 jne	 SHORT $LN15@gz_comp

; 80   :         return -1;

  00029	83 c8 ff	 or	 eax, -1
  0002c	e9 85 01 00 00	 jmp	 $LN16@gz_comp
$LN15@gz_comp:

; 81   : 
; 82   :     /* write directly if requested */
; 83   :     if (state->direct) {

  00031	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00034	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00038	74 68		 je	 SHORT $LN14@gz_comp

; 84   :         got = write(state->fd, strm->next_in, strm->avail_in);

  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00040	52		 push	 edx
  00041	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  00044	8b 08		 mov	 ecx, DWORD PTR [eax]
  00046	51		 push	 ecx
  00047	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0004a	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 _write
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	89 45 f0	 mov	 DWORD PTR _got$[ebp], eax

; 85   :         if (got < 0 || (unsigned)got != strm->avail_in) {

  00059	83 7d f0 00	 cmp	 DWORD PTR _got$[ebp], 0
  0005d	7c 0b		 jl	 SHORT $LN12@gz_comp
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  00062	8b 55 f0	 mov	 edx, DWORD PTR _got$[ebp]
  00065	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00068	74 27		 je	 SHORT $LN13@gz_comp
$LN12@gz_comp:

; 86   :             gz_error(state, Z_ERRNO, zstrerror());

  0006a	e8 00 00 00 00	 call	 __errno
  0006f	8b 00		 mov	 eax, DWORD PTR [eax]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _strerror
  00077	83 c4 04	 add	 esp, 4
  0007a	50		 push	 eax
  0007b	6a ff		 push	 -1
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 _gz_error
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH

; 87   :             return -1;

  00089	83 c8 ff	 or	 eax, -1
  0008c	e9 25 01 00 00	 jmp	 $LN16@gz_comp
$LN13@gz_comp:

; 88   :         }
; 89   :         strm->avail_in = 0;

  00091	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  00094	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 90   :         return 0;

  0009b	33 c0		 xor	 eax, eax
  0009d	e9 14 01 00 00	 jmp	 $LN16@gz_comp
$LN14@gz_comp:

; 91   :     }
; 92   : 
; 93   :     /* run deflate() on provided input until it produces no more output */
; 94   :     ret = Z_OK;

  000a2	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
$LN11@gz_comp:

; 95   :     do {
; 96   :         /* write out current buffer contents if full, or if flushing, but if
; 97   :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 98   :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
; 99   :             (flush != Z_FINISH || ret == Z_STREAM_END))) {

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  000ac	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000b0	74 1a		 je	 SHORT $LN7@gz_comp
  000b2	83 7d 0c 00	 cmp	 DWORD PTR _flush$[ebp], 0
  000b6	0f 84 a0 00 00
	00		 je	 $LN8@gz_comp
  000bc	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  000c0	75 0a		 jne	 SHORT $LN7@gz_comp
  000c2	83 7d f4 01	 cmp	 DWORD PTR _ret$[ebp], 1
  000c6	0f 85 90 00 00
	00		 jne	 $LN8@gz_comp
$LN7@gz_comp:

; 100  :             have = (unsigned)(strm->next_out - state->x.next);

  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  000cf	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000d2	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000d5	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  000d8	89 45 fc	 mov	 DWORD PTR _have$[ebp], eax

; 101  :             if (have && ((got = write(state->fd, state->x.next, have)) < 0 ||
; 102  :                          (unsigned)got != have)) {

  000db	74 52		 je	 SHORT $LN5@gz_comp
  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _have$[ebp]
  000e0	51		 push	 ecx
  000e1	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000e4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000e7	50		 push	 eax
  000e8	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000eb	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 _write
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f7	89 45 f0	 mov	 DWORD PTR _got$[ebp], eax
  000fa	83 7d f0 00	 cmp	 DWORD PTR _got$[ebp], 0
  000fe	7c 08		 jl	 SHORT $LN4@gz_comp
  00100	8b 45 f0	 mov	 eax, DWORD PTR _got$[ebp]
  00103	3b 45 fc	 cmp	 eax, DWORD PTR _have$[ebp]
  00106	74 27		 je	 SHORT $LN5@gz_comp
$LN4@gz_comp:

; 103  :                 gz_error(state, Z_ERRNO, zstrerror());

  00108	e8 00 00 00 00	 call	 __errno
  0010d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010f	51		 push	 ecx
  00110	e8 00 00 00 00	 call	 _strerror
  00115	83 c4 04	 add	 esp, 4
  00118	50		 push	 eax
  00119	6a ff		 push	 -1
  0011b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0011e	52		 push	 edx
  0011f	e8 00 00 00 00	 call	 _gz_error
  00124	83 c4 0c	 add	 esp, 12			; 0000000cH

; 104  :                 return -1;

  00127	83 c8 ff	 or	 eax, -1
  0012a	e9 87 00 00 00	 jmp	 $LN16@gz_comp
$LN5@gz_comp:

; 105  :             }
; 106  :             if (strm->avail_out == 0) {

  0012f	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  00132	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00136	75 18		 jne	 SHORT $LN3@gz_comp

; 107  :                 strm->avail_out = state->size;

  00138	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  0013b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0013e	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00141	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 108  :                 strm->next_out = state->out;

  00144	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  00147	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0014a	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0014d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN3@gz_comp:

; 109  :             }
; 110  :             state->x.next = strm->next_out;

  00150	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00153	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  00156	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00159	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN8@gz_comp:

; 111  :         }
; 112  : 
; 113  :         /* compress */
; 114  :         have = strm->avail_out;

  0015c	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  0015f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00162	89 55 fc	 mov	 DWORD PTR _have$[ebp], edx

; 115  :         ret = deflate(strm, flush);

  00165	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  00168	50		 push	 eax
  00169	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 _deflate@8
  00172	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax

; 116  :         if (ret == Z_STREAM_ERROR) {

  00175	83 7d f4 fe	 cmp	 DWORD PTR _ret$[ebp], -2 ; fffffffeH
  00179	75 18		 jne	 SHORT $LN2@gz_comp

; 117  :             gz_error(state, Z_STREAM_ERROR,
; 118  :                       "internal error: deflate stream corrupt");

  0017b	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
  00180	6a fe		 push	 -2			; fffffffeH
  00182	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00185	52		 push	 edx
  00186	e8 00 00 00 00	 call	 _gz_error
  0018b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 119  :             return -1;

  0018e	83 c8 ff	 or	 eax, -1
  00191	eb 23		 jmp	 SHORT $LN16@gz_comp
$LN2@gz_comp:

; 120  :         }
; 121  :         have -= strm->avail_out;

  00193	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  00196	8b 4d fc	 mov	 ecx, DWORD PTR _have$[ebp]
  00199	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  0019c	89 4d fc	 mov	 DWORD PTR _have$[ebp], ecx

; 122  :     } while (have);

  0019f	0f 85 04 ff ff
	ff		 jne	 $LN11@gz_comp

; 123  : 
; 124  :     /* if that completed a deflate stream, allow another to start */
; 125  :     if (flush == Z_FINISH)

  001a5	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  001a9	75 09		 jne	 SHORT $LN1@gz_comp

; 126  :         deflateReset(strm);

  001ab	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  001ae	52		 push	 edx
  001af	e8 00 00 00 00	 call	 _deflateReset@4
$LN1@gz_comp:

; 127  : 
; 128  :     /* all done, no errors */
; 129  :     return 0;

  001b4	33 c0		 xor	 eax, eax
$LN16@gz_comp:

; 130  : }

  001b6	8b e5		 mov	 esp, ebp
  001b8	5d		 pop	 ebp
  001b9	c3		 ret	 0
_gz_comp ENDP
; Function compile flags: /Odtp
;	COMDAT _gz_zero
_TEXT	SEGMENT
tv78 = -24						; size = 4
tv140 = -20						; size = 8
_strm$ = -12						; size = 4
_n$ = -8						; size = 4
_first$ = -4						; size = 4
_state$ = 8						; size = 4
_len$ = 12						; size = 8
_gz_zero PROC						; COMDAT

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 137  :     int first;
; 138  :     unsigned n;
; 139  :     z_streamp strm = &(state->strm);

  00006	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00009	83 c0 64	 add	 eax, 100		; 00000064H
  0000c	89 45 f4	 mov	 DWORD PTR _strm$[ebp], eax

; 140  : 
; 141  :     /* consume whatever's left in the input buffer */
; 142  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00012	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00016	74 1b		 je	 SHORT $LN5@gz_zero
  00018	6a 00		 push	 0
  0001a	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 _gz_comp
  00023	83 c4 08	 add	 esp, 8
  00026	83 f8 ff	 cmp	 eax, -1
  00029	75 08		 jne	 SHORT $LN5@gz_zero

; 143  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1
  0002e	e9 d1 00 00 00	 jmp	 $LN6@gz_zero
$LN5@gz_zero:

; 144  : 
; 145  :     /* compress len zeros (len guaranteed > 0) */
; 146  :     first = 1;

  00033	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _first$[ebp], 1
$LN4@gz_zero:

; 147  :     while (len) {

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  0003d	0b 45 10	 or	 eax, DWORD PTR _len$[ebp+4]
  00040	0f 84 bc 00 00
	00		 je	 $LN3@gz_zero

; 148  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
; 149  :             (unsigned)len : state->size;

  00046	33 c9		 xor	 ecx, ecx
  00048	75 2b		 jne	 SHORT $LN8@gz_zero
  0004a	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0004d	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00050	33 c9		 xor	 ecx, ecx
  00052	89 45 ec	 mov	 DWORD PTR tv140[ebp], eax
  00055	89 4d f0	 mov	 DWORD PTR tv140[ebp+4], ecx
  00058	8b 55 f0	 mov	 edx, DWORD PTR tv140[ebp+4]
  0005b	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp+4]
  0005e	7f 15		 jg	 SHORT $LN8@gz_zero
  00060	7c 08		 jl	 SHORT $LN10@gz_zero
  00062	8b 45 ec	 mov	 eax, DWORD PTR tv140[ebp]
  00065	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  00068	77 0b		 ja	 SHORT $LN8@gz_zero
$LN10@gz_zero:
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0006d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00070	89 55 e8	 mov	 DWORD PTR tv78[ebp], edx
  00073	eb 06		 jmp	 SHORT $LN9@gz_zero
$LN8@gz_zero:
  00075	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00078	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
$LN9@gz_zero:
  0007b	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  0007e	89 4d f8	 mov	 DWORD PTR _n$[ebp], ecx

; 150  :         if (first) {

  00081	83 7d fc 00	 cmp	 DWORD PTR _first$[ebp], 0
  00085	74 1c		 je	 SHORT $LN2@gz_zero

; 151  :             memset(state->in, 0, n);

  00087	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  0008a	52		 push	 edx
  0008b	6a 00		 push	 0
  0008d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00090	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _memset
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH

; 152  :             first = 0;

  0009c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _first$[ebp], 0
$LN2@gz_zero:

; 153  :         }
; 154  :         strm->avail_in = n;

  000a3	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  000a6	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000a9	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 155  :         strm->next_in = state->in;

  000ac	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  000af	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000b2	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000b5	89 01		 mov	 DWORD PTR [ecx], eax

; 156  :         state->x.pos += n;

  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  000ba	33 d2		 xor	 edx, edx
  000bc	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000bf	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  000c2	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000c5	13 c2		 adc	 eax, edx
  000c7	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000ca	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  000cd	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 157  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  000d0	6a 00		 push	 0
  000d2	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _gz_comp
  000db	83 c4 08	 add	 esp, 8
  000de	83 f8 ff	 cmp	 eax, -1
  000e1	75 05		 jne	 SHORT $LN1@gz_zero

; 158  :             return -1;

  000e3	83 c8 ff	 or	 eax, -1
  000e6	eb 1c		 jmp	 SHORT $LN6@gz_zero
$LN1@gz_zero:

; 159  :         len -= n;

  000e8	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  000eb	33 d2		 xor	 edx, edx
  000ed	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  000f0	2b c1		 sub	 eax, ecx
  000f2	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp+4]
  000f5	1b ca		 sbb	 ecx, edx
  000f7	89 45 0c	 mov	 DWORD PTR _len$[ebp], eax
  000fa	89 4d 10	 mov	 DWORD PTR _len$[ebp+4], ecx

; 160  :     }

  000fd	e9 38 ff ff ff	 jmp	 $LN4@gz_zero
$LN3@gz_zero:

; 161  :     return 0;

  00102	33 c0		 xor	 eax, eax
$LN6@gz_zero:

; 162  : }

  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
_gz_zero ENDP
PUBLIC	_gzclose_w@4
; Function compile flags: /Odtp
;	COMDAT _gzclose_w@4
_TEXT	SEGMENT
_state$ = -8						; size = 4
_ret$ = -4						; size = 4
_file$ = 8						; size = 4
_gzclose_w@4 PROC					; COMDAT

; 541  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 542  :     int ret = Z_OK;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 543  :     gz_statep state;
; 544  : 
; 545  :     /* get internal structure */
; 546  :     if (file == NULL)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00011	75 0a		 jne	 SHORT $LN8@gzclose_w

; 547  :         return Z_STREAM_ERROR;

  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	e9 f5 00 00 00	 jmp	 $LN9@gzclose_w
$LN8@gzclose_w:

; 548  :     state = (gz_statep)file;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00020	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 549  : 
; 550  :     /* check that we're writing */
; 551  :     if (state->mode != GZ_WRITE)

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00026	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  0002d	74 0a		 je	 SHORT $LN7@gzclose_w

; 552  :         return Z_STREAM_ERROR;

  0002f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00034	e9 d9 00 00 00	 jmp	 $LN9@gzclose_w
$LN7@gzclose_w:

; 553  : 
; 554  :     /* check for seek request */
; 555  :     if (state->seek) {

  00039	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0003c	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  00040	74 2f		 je	 SHORT $LN6@gzclose_w

; 556  :         state->seek = 0;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00045	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 557  :         if (gz_zero(state, state->skip) == -1)

  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0004f	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00052	52		 push	 edx
  00053	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00056	50		 push	 eax
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0005a	51		 push	 ecx
  0005b	e8 00 00 00 00	 call	 _gz_zero
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	83 f8 ff	 cmp	 eax, -1
  00066	75 09		 jne	 SHORT $LN6@gzclose_w

; 558  :             ret = state->err;

  00068	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0006b	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  0006e	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
$LN6@gzclose_w:

; 559  :     }
; 560  : 
; 561  :     /* flush, free memory, and close file */
; 562  :     if (gz_comp(state, Z_FINISH) == -1)

  00071	6a 04		 push	 4
  00073	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 _gz_comp
  0007c	83 c4 08	 add	 esp, 8
  0007f	83 f8 ff	 cmp	 eax, -1
  00082	75 09		 jne	 SHORT $LN4@gzclose_w

; 563  :         ret = state->err;

  00084	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00087	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  0008a	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
$LN4@gzclose_w:

; 564  :     if (state->size) {

  0008d	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00090	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00094	74 33		 je	 SHORT $LN3@gzclose_w

; 565  :         if (!state->direct) {

  00096	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00099	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  0009d	75 1b		 jne	 SHORT $LN2@gzclose_w

; 566  :             (void)deflateEnd(&(state->strm));

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000a2	83 c0 64	 add	 eax, 100		; 00000064H
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _deflateEnd@4

; 567  :             free(state->out);

  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000ae	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000b1	52		 push	 edx
  000b2	e8 00 00 00 00	 call	 _free
  000b7	83 c4 04	 add	 esp, 4
$LN2@gzclose_w:

; 568  :         }
; 569  :         free(state->in);

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000bd	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000c0	51		 push	 ecx
  000c1	e8 00 00 00 00	 call	 _free
  000c6	83 c4 04	 add	 esp, 4
$LN3@gzclose_w:

; 570  :     }
; 571  :     gz_error(state, Z_OK, NULL);

  000c9	6a 00		 push	 0
  000cb	6a 00		 push	 0
  000cd	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 _gz_error
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 572  :     free(state->path);

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000dc	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _free
  000e5	83 c4 04	 add	 esp, 4

; 573  :     if (close(state->fd) == -1)

  000e8	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000eb	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _close
  000f4	83 c4 04	 add	 esp, 4
  000f7	83 f8 ff	 cmp	 eax, -1
  000fa	75 07		 jne	 SHORT $LN1@gzclose_w

; 574  :         ret = Z_ERRNO;

  000fc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -1
$LN1@gzclose_w:

; 575  :     free(state);

  00103	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00106	51		 push	 ecx
  00107	e8 00 00 00 00	 call	 _free
  0010c	83 c4 04	 add	 esp, 4

; 576  :     return ret;

  0010f	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
$LN9@gzclose_w:

; 577  : }

  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c2 04 00	 ret	 4
_gzclose_w@4 ENDP
_TEXT	ENDS
PUBLIC	_gzsetparams@12
; Function compile flags: /Odtp
;	COMDAT _gzsetparams@12
_TEXT	SEGMENT
_state$ = -8						; size = 4
_strm$ = -4						; size = 4
_file$ = 8						; size = 4
_level$ = 12						; size = 4
_strategy$ = 16						; size = 4
_gzsetparams@12 PROC					; COMDAT

; 501  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 502  :     gz_statep state;
; 503  :     z_streamp strm;
; 504  : 
; 505  :     /* get internal structure */
; 506  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 0a		 jne	 SHORT $LN8@gzsetparam

; 507  :         return Z_STREAM_ERROR;

  0000c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00011	e9 d1 00 00 00	 jmp	 $LN9@gzsetparam
$LN8@gzsetparam:

; 508  :     state = (gz_statep)file;

  00016	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00019	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 509  :     strm = &(state->strm);

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0001f	83 c1 64	 add	 ecx, 100		; 00000064H
  00022	89 4d fc	 mov	 DWORD PTR _strm$[ebp], ecx

; 510  : 
; 511  :     /* check that we're writing and that there's no error */
; 512  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00025	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00028	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002f	75 09		 jne	 SHORT $LN6@gzsetparam
  00031	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00034	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00038	74 0a		 je	 SHORT $LN7@gzsetparam
$LN6@gzsetparam:

; 513  :         return Z_STREAM_ERROR;

  0003a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0003f	e9 a3 00 00 00	 jmp	 $LN9@gzsetparam
$LN7@gzsetparam:

; 514  : 
; 515  :     /* if no change is requested, then do nothing */
; 516  :     if (level == state->level && strategy == state->strategy)

  00044	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00047	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  0004a	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  0004d	75 12		 jne	 SHORT $LN5@gzsetparam
  0004f	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00052	8b 4d 10	 mov	 ecx, DWORD PTR _strategy$[ebp]
  00055	3b 48 4c	 cmp	 ecx, DWORD PTR [eax+76]
  00058	75 07		 jne	 SHORT $LN5@gzsetparam

; 517  :         return Z_OK;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 86 00 00 00	 jmp	 $LN9@gzsetparam
$LN5@gzsetparam:

; 518  : 
; 519  :     /* check for seek request */
; 520  :     if (state->seek) {

  00061	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00064	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  00068	74 2b		 je	 SHORT $LN4@gzsetparam

; 521  :         state->seek = 0;

  0006a	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0006d	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 522  :         if (gz_zero(state, state->skip) == -1)

  00074	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00077	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0007a	52		 push	 edx
  0007b	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  0007e	50		 push	 eax
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _gz_zero
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008b	83 f8 ff	 cmp	 eax, -1
  0008e	75 05		 jne	 SHORT $LN4@gzsetparam

; 523  :             return -1;

  00090	83 c8 ff	 or	 eax, -1
  00093	eb 52		 jmp	 SHORT $LN9@gzsetparam
$LN4@gzsetparam:

; 524  :     }
; 525  : 
; 526  :     /* change compression parameters for subsequent input */
; 527  :     if (state->size) {

  00095	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00098	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  0009c	74 35		 je	 SHORT $LN2@gzsetparam

; 528  :         /* flush previous input with previous parameters before changing */
; 529  :         if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)

  0009e	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  000a1	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000a5	74 1b		 je	 SHORT $LN1@gzsetparam
  000a7	6a 01		 push	 1
  000a9	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000ac	51		 push	 ecx
  000ad	e8 00 00 00 00	 call	 _gz_comp
  000b2	83 c4 08	 add	 esp, 8
  000b5	83 f8 ff	 cmp	 eax, -1
  000b8	75 08		 jne	 SHORT $LN1@gzsetparam

; 530  :             return state->err;

  000ba	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000bd	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  000c0	eb 25		 jmp	 SHORT $LN9@gzsetparam
$LN1@gzsetparam:

; 531  :         deflateParams(strm, level, strategy);

  000c2	8b 45 10	 mov	 eax, DWORD PTR _strategy$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d 0c	 mov	 ecx, DWORD PTR _level$[ebp]
  000c9	51		 push	 ecx
  000ca	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000cd	52		 push	 edx
  000ce	e8 00 00 00 00	 call	 _deflateParams@12
$LN2@gzsetparam:

; 532  :     }
; 533  :     state->level = level;

  000d3	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000d6	8b 4d 0c	 mov	 ecx, DWORD PTR _level$[ebp]
  000d9	89 48 48	 mov	 DWORD PTR [eax+72], ecx

; 534  :     state->strategy = strategy;

  000dc	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000df	8b 45 10	 mov	 eax, DWORD PTR _strategy$[ebp]
  000e2	89 42 4c	 mov	 DWORD PTR [edx+76], eax

; 535  :     return Z_OK;

  000e5	33 c0		 xor	 eax, eax
$LN9@gzsetparam:

; 536  : }

  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 0c 00	 ret	 12			; 0000000cH
_gzsetparams@12 ENDP
_TEXT	ENDS
PUBLIC	_gzflush@8
; Function compile flags: /Odtp
;	COMDAT _gzflush@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_flush$ = 12						; size = 4
_gzflush@8 PROC						; COMDAT

; 468  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 469  :     gz_statep state;
; 470  : 
; 471  :     /* get internal structure */
; 472  :     if (file == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00008	75 05		 jne	 SHORT $LN7@gzflush

; 473  :         return -1;

  0000a	83 c8 ff	 or	 eax, -1
  0000d	eb 7f		 jmp	 SHORT $LN8@gzflush
$LN7@gzflush:

; 474  :     state = (gz_statep)file;

  0000f	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 475  : 
; 476  :     /* check that we're writing and that there's no error */
; 477  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00018	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  0001f	75 09		 jne	 SHORT $LN5@gzflush
  00021	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00024	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  00028	74 07		 je	 SHORT $LN6@gzflush
$LN5@gzflush:

; 478  :         return Z_STREAM_ERROR;

  0002a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002f	eb 5d		 jmp	 SHORT $LN8@gzflush
$LN6@gzflush:

; 479  : 
; 480  :     /* check flush parameter */
; 481  :     if (flush < 0 || flush > Z_FINISH)

  00031	83 7d 0c 00	 cmp	 DWORD PTR _flush$[ebp], 0
  00035	7c 06		 jl	 SHORT $LN3@gzflush
  00037	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0003b	7e 07		 jle	 SHORT $LN4@gzflush
$LN3@gzflush:

; 482  :         return Z_STREAM_ERROR;

  0003d	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00042	eb 4a		 jmp	 SHORT $LN8@gzflush
$LN4@gzflush:

; 483  : 
; 484  :     /* check for seek request */
; 485  :     if (state->seek) {

  00044	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00047	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  0004b	74 2b		 je	 SHORT $LN2@gzflush

; 486  :         state->seek = 0;

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00050	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 487  :         if (gz_zero(state, state->skip) == -1)

  00057	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0005a	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  0005d	50		 push	 eax
  0005e	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  00061	51		 push	 ecx
  00062	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 _gz_zero
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006e	83 f8 ff	 cmp	 eax, -1
  00071	75 05		 jne	 SHORT $LN2@gzflush

; 488  :             return -1;

  00073	83 c8 ff	 or	 eax, -1
  00076	eb 16		 jmp	 SHORT $LN8@gzflush
$LN2@gzflush:

; 489  :     }
; 490  : 
; 491  :     /* compress remaining data with requested flush */
; 492  :     gz_comp(state, flush);

  00078	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  0007b	50		 push	 eax
  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 _gz_comp
  00085	83 c4 08	 add	 esp, 8

; 493  :     return state->err;

  00088	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0008b	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
$LN8@gzflush:

; 494  : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 08 00	 ret	 8
_gzflush@8 ENDP
_TEXT	ENDS
PUBLIC	_gzvprintf
; Function compile flags: /Odtp
;	COMDAT _gzvprintf
_TEXT	SEGMENT
_state$ = -16						; size = 4
_size$ = -12						; size = 4
_len$ = -8						; size = 4
_strm$ = -4						; size = 4
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_va$ = 16						; size = 4
_gzvprintf PROC						; COMDAT

; 311  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 312  :     int size, len;
; 313  :     gz_statep state;
; 314  :     z_streamp strm;
; 315  : 
; 316  :     /* get internal structure */
; 317  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN9@gzvprintf

; 318  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	e9 2d 01 00 00	 jmp	 $LN10@gzvprintf
$LN9@gzvprintf:

; 319  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 320  :     strm = &(state->strm);

  0001a	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	83 c1 64	 add	 ecx, 100		; 00000064H
  00020	89 4d fc	 mov	 DWORD PTR _strm$[ebp], ecx

; 321  : 
; 322  :     /* check that we're writing and that there's no error */
; 323  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00023	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00026	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002d	75 09		 jne	 SHORT $LN7@gzvprintf
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00032	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00036	74 07		 je	 SHORT $LN8@gzvprintf
$LN7@gzvprintf:

; 324  :         return 0;

  00038	33 c0		 xor	 eax, eax
  0003a	e9 02 01 00 00	 jmp	 $LN10@gzvprintf
$LN8@gzvprintf:

; 325  : 
; 326  :     /* make sure we have some buffer space */
; 327  :     if (state->size == 0 && gz_init(state) == -1)

  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00042	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00046	75 18		 jne	 SHORT $LN6@gzvprintf
  00048	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 _gz_init
  00051	83 c4 04	 add	 esp, 4
  00054	83 f8 ff	 cmp	 eax, -1
  00057	75 07		 jne	 SHORT $LN6@gzvprintf

; 328  :         return 0;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 e1 00 00 00	 jmp	 $LN10@gzvprintf
$LN6@gzvprintf:

; 329  : 
; 330  :     /* check for seek request */
; 331  :     if (state->seek) {

  00060	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00063	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  00067	74 2d		 je	 SHORT $LN5@gzvprintf

; 332  :         state->seek = 0;

  00069	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0006c	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 333  :         if (gz_zero(state, state->skip) == -1)

  00073	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00076	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00079	50		 push	 eax
  0007a	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  0007d	51		 push	 ecx
  0007e	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00081	52		 push	 edx
  00082	e8 00 00 00 00	 call	 _gz_zero
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008a	83 f8 ff	 cmp	 eax, -1
  0008d	75 07		 jne	 SHORT $LN5@gzvprintf

; 334  :             return 0;

  0008f	33 c0		 xor	 eax, eax
  00091	e9 ab 00 00 00	 jmp	 $LN10@gzvprintf
$LN5@gzvprintf:

; 335  :     }
; 336  : 
; 337  :     /* consume whatever's left in the input buffer */
; 338  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00096	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00099	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0009d	74 1a		 je	 SHORT $LN3@gzvprintf
  0009f	6a 00		 push	 0
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 _gz_comp
  000aa	83 c4 08	 add	 esp, 8
  000ad	83 f8 ff	 cmp	 eax, -1
  000b0	75 07		 jne	 SHORT $LN3@gzvprintf

; 339  :         return 0;

  000b2	33 c0		 xor	 eax, eax
  000b4	e9 88 00 00 00	 jmp	 $LN10@gzvprintf
$LN3@gzvprintf:

; 340  : 
; 341  :     /* do the printf() into the input buffer, put length in len */
; 342  :     size = (int)(state->size);

  000b9	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000bc	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000bf	89 45 f4	 mov	 DWORD PTR _size$[ebp], eax

; 343  :     state->in[size - 1] = 0;

  000c2	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000c5	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000c8	8b 45 f4	 mov	 eax, DWORD PTR _size$[ebp]
  000cb	c6 44 10 ff 00	 mov	 BYTE PTR [eax+edx-1], 0

; 344  : #ifdef NO_vsnprintf
; 345  : #  ifdef HAS_vsprintf_void
; 346  :     (void)vsprintf((char *)(state->in), format, va);
; 347  :     for (len = 0; len < size; len++)
; 348  :         if (state->in[len] == 0) break;
; 349  : #  else
; 350  :     len = vsprintf((char *)(state->in), format, va);
; 351  : #  endif
; 352  : #else
; 353  : #  ifdef HAS_vsnprintf_void
; 354  :     (void)vsnprintf((char *)(state->in), size, format, va);
; 355  :     len = strlen((char *)(state->in));
; 356  : #  else
; 357  :     len = vsnprintf((char *)(state->in), size, format, va);

  000d0	8b 4d 10	 mov	 ecx, DWORD PTR _va$[ebp]
  000d3	51		 push	 ecx
  000d4	8b 55 0c	 mov	 edx, DWORD PTR _format$[ebp]
  000d7	52		 push	 edx
  000d8	8b 45 f4	 mov	 eax, DWORD PTR _size$[ebp]
  000db	50		 push	 eax
  000dc	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000df	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000e2	52		 push	 edx
  000e3	e8 00 00 00 00	 call	 _vsnprintf
  000e8	83 c4 10	 add	 esp, 16			; 00000010H
  000eb	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 358  : #  endif
; 359  : #endif
; 360  : 
; 361  :     /* check that printf() results fit in buffer */
; 362  :     if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)

  000ee	83 7d f8 00	 cmp	 DWORD PTR _len$[ebp], 0
  000f2	7e 1a		 jle	 SHORT $LN1@gzvprintf
  000f4	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  000f7	3b 45 f4	 cmp	 eax, DWORD PTR _size$[ebp]
  000fa	7d 12		 jge	 SHORT $LN1@gzvprintf
  000fc	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000ff	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00102	8b 45 f4	 mov	 eax, DWORD PTR _size$[ebp]
  00105	0f b6 4c 02 ff	 movzx	 ecx, BYTE PTR [edx+eax-1]
  0010a	85 c9		 test	 ecx, ecx
  0010c	74 04		 je	 SHORT $LN2@gzvprintf
$LN1@gzvprintf:

; 363  :         return 0;

  0010e	33 c0		 xor	 eax, eax
  00110	eb 2f		 jmp	 SHORT $LN10@gzvprintf
$LN2@gzvprintf:

; 364  : 
; 365  :     /* update buffer and position, defer compression until needed */
; 366  :     strm->avail_in = (unsigned)len;

  00112	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  00115	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00118	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 367  :     strm->next_in = state->in;

  0011b	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  0011e	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00121	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00124	89 01		 mov	 DWORD PTR [ecx], eax

; 368  :     state->x.pos += len;

  00126	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00129	99		 cdq
  0012a	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0012d	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00130	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00133	13 ca		 adc	 ecx, edx
  00135	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00138	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0013b	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 369  :     return len;

  0013e	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
$LN10@gzvprintf:

; 370  : }

  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c3		 ret	 0
_gzvprintf ENDP
_TEXT	ENDS
PUBLIC	_gzwrite@12
; Function compile flags: /Odtp
;	COMDAT _gzwrite@12
_TEXT	SEGMENT
_copy$79608 = -20					; size = 4
_have$79607 = -16					; size = 4
_state$ = -12						; size = 4
_strm$ = -8						; size = 4
_put$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzwrite@12 PROC					; COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 170  :     unsigned put = len;

  00006	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax

; 171  :     gz_statep state;
; 172  :     z_streamp strm;
; 173  : 
; 174  :     /* get internal structure */
; 175  :     if (file == NULL)

  0000c	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00010	75 07		 jne	 SHORT $LN18@gzwrite

; 176  :         return 0;

  00012	33 c0		 xor	 eax, eax
  00014	e9 dd 01 00 00	 jmp	 $LN19@gzwrite
$LN18@gzwrite:

; 177  :     state = (gz_statep)file;

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR _state$[ebp], ecx

; 178  :     strm = &(state->strm);

  0001f	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00022	83 c2 64	 add	 edx, 100		; 00000064H
  00025	89 55 f8	 mov	 DWORD PTR _strm$[ebp], edx

; 179  : 
; 180  :     /* check that we're writing and that there's no error */
; 181  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00028	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	81 78 10 b1 79
	00 00		 cmp	 DWORD PTR [eax+16], 31153 ; 000079b1H
  00032	75 09		 jne	 SHORT $LN16@gzwrite
  00034	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00037	83 79 5c 00	 cmp	 DWORD PTR [ecx+92], 0
  0003b	74 07		 je	 SHORT $LN17@gzwrite
$LN16@gzwrite:

; 182  :         return 0;

  0003d	33 c0		 xor	 eax, eax
  0003f	e9 b2 01 00 00	 jmp	 $LN19@gzwrite
$LN17@gzwrite:

; 183  : 
; 184  :     /* since an int is returned, make sure len fits in one, otherwise return
; 185  :        with an error (this avoids the flaw in the interface) */
; 186  :     if ((int)len < 0) {

  00044	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00048	7d 1a		 jge	 SHORT $LN15@gzwrite

; 187  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  0004f	6a fd		 push	 -3			; fffffffdH
  00051	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 _gz_error
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 188  :         return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	e9 92 01 00 00	 jmp	 $LN19@gzwrite
$LN15@gzwrite:

; 189  :     }
; 190  : 
; 191  :     /* if len is zero, avoid unnecessary operations */
; 192  :     if (len == 0)

  00064	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00068	75 07		 jne	 SHORT $LN14@gzwrite

; 193  :         return 0;

  0006a	33 c0		 xor	 eax, eax
  0006c	e9 85 01 00 00	 jmp	 $LN19@gzwrite
$LN14@gzwrite:

; 194  : 
; 195  :     /* allocate memory if this is the first time through */
; 196  :     if (state->size == 0 && gz_init(state) == -1)

  00071	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00074	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00078	75 18		 jne	 SHORT $LN13@gzwrite
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0007d	51		 push	 ecx
  0007e	e8 00 00 00 00	 call	 _gz_init
  00083	83 c4 04	 add	 esp, 4
  00086	83 f8 ff	 cmp	 eax, -1
  00089	75 07		 jne	 SHORT $LN13@gzwrite

; 197  :         return 0;

  0008b	33 c0		 xor	 eax, eax
  0008d	e9 64 01 00 00	 jmp	 $LN19@gzwrite
$LN13@gzwrite:

; 198  : 
; 199  :     /* check for seek request */
; 200  :     if (state->seek) {

  00092	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00095	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  00099	74 2d		 je	 SHORT $LN12@gzwrite

; 201  :         state->seek = 0;

  0009b	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0009e	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 202  :         if (gz_zero(state, state->skip) == -1)

  000a5	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  000a8	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  000ab	52		 push	 edx
  000ac	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  000af	50		 push	 eax
  000b0	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  000b3	51		 push	 ecx
  000b4	e8 00 00 00 00	 call	 _gz_zero
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bc	83 f8 ff	 cmp	 eax, -1
  000bf	75 07		 jne	 SHORT $LN12@gzwrite

; 203  :             return 0;

  000c1	33 c0		 xor	 eax, eax
  000c3	e9 2e 01 00 00	 jmp	 $LN19@gzwrite
$LN12@gzwrite:

; 204  :     }
; 205  : 
; 206  :     /* for small len, copy to input buffer, otherwise compress directly */
; 207  :     if (len < state->size) {

  000c8	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  000cb	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  000ce	3b 42 1c	 cmp	 eax, DWORD PTR [edx+28]
  000d1	0f 83 bb 00 00
	00		 jae	 $LN10@gzwrite
$LN9@gzwrite:

; 208  :         /* copy to input buffer, compress when full */
; 209  :         do {
; 210  :             unsigned have, copy;
; 211  : 
; 212  :             if (strm->avail_in == 0)

  000d7	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  000da	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  000de	75 0b		 jne	 SHORT $LN6@gzwrite

; 213  :                 strm->next_in = state->in;

  000e0	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  000e3	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  000e6	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000e9	89 0a		 mov	 DWORD PTR [edx], ecx
$LN6@gzwrite:

; 214  :             have = (unsigned)((strm->next_in + strm->avail_in) - state->in);

  000eb	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  000ee	8b 02		 mov	 eax, DWORD PTR [edx]
  000f0	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  000f3	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000f6	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  000f9	2b 42 24	 sub	 eax, DWORD PTR [edx+36]
  000fc	89 45 f0	 mov	 DWORD PTR _have$79607[ebp], eax

; 215  :             copy = state->size - have;

  000ff	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00102	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00105	2b 4d f0	 sub	 ecx, DWORD PTR _have$79607[ebp]
  00108	89 4d ec	 mov	 DWORD PTR _copy$79608[ebp], ecx

; 216  :             if (copy > len)

  0010b	8b 55 ec	 mov	 edx, DWORD PTR _copy$79608[ebp]
  0010e	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp]
  00111	76 06		 jbe	 SHORT $LN5@gzwrite

; 217  :                 copy = len;

  00113	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00116	89 45 ec	 mov	 DWORD PTR _copy$79608[ebp], eax
$LN5@gzwrite:

; 218  :             memcpy(state->in + have, buf, copy);

  00119	8b 4d ec	 mov	 ecx, DWORD PTR _copy$79608[ebp]
  0011c	51		 push	 ecx
  0011d	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00120	52		 push	 edx
  00121	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00124	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00127	03 4d f0	 add	 ecx, DWORD PTR _have$79607[ebp]
  0012a	51		 push	 ecx
  0012b	e8 00 00 00 00	 call	 _memcpy
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH

; 219  :             strm->avail_in += copy;

  00133	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  00136	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00139	03 45 ec	 add	 eax, DWORD PTR _copy$79608[ebp]
  0013c	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  0013f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 220  :             state->x.pos += copy;

  00142	8b 55 ec	 mov	 edx, DWORD PTR _copy$79608[ebp]
  00145	33 c0		 xor	 eax, eax
  00147	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0014a	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  0014d	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00150	13 c8		 adc	 ecx, eax
  00152	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00155	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00158	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 221  :             buf = (const char *)buf + copy;

  0015b	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0015e	03 4d ec	 add	 ecx, DWORD PTR _copy$79608[ebp]
  00161	89 4d 0c	 mov	 DWORD PTR _buf$[ebp], ecx

; 222  :             len -= copy;

  00164	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00167	2b 55 ec	 sub	 edx, DWORD PTR _copy$79608[ebp]
  0016a	89 55 10	 mov	 DWORD PTR _len$[ebp], edx

; 223  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  0016d	74 17		 je	 SHORT $LN8@gzwrite
  0016f	6a 00		 push	 0
  00171	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 _gz_comp
  0017a	83 c4 08	 add	 esp, 8
  0017d	83 f8 ff	 cmp	 eax, -1
  00180	75 04		 jne	 SHORT $LN8@gzwrite

; 224  :                 return 0;

  00182	33 c0		 xor	 eax, eax
  00184	eb 70		 jmp	 SHORT $LN19@gzwrite
$LN8@gzwrite:

; 225  :         } while (len);

  00186	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  0018a	0f 85 47 ff ff
	ff		 jne	 $LN9@gzwrite

; 226  :     }
; 227  :     else {

  00190	eb 61		 jmp	 SHORT $LN3@gzwrite
$LN10@gzwrite:

; 228  :         /* consume whatever's left in the input buffer */
; 229  :         if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00192	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  00195	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00199	74 17		 je	 SHORT $LN2@gzwrite
  0019b	6a 00		 push	 0
  0019d	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  001a0	52		 push	 edx
  001a1	e8 00 00 00 00	 call	 _gz_comp
  001a6	83 c4 08	 add	 esp, 8
  001a9	83 f8 ff	 cmp	 eax, -1
  001ac	75 04		 jne	 SHORT $LN2@gzwrite

; 230  :             return 0;

  001ae	33 c0		 xor	 eax, eax
  001b0	eb 44		 jmp	 SHORT $LN19@gzwrite
$LN2@gzwrite:

; 231  : 
; 232  :         /* directly compress user buffer to file */
; 233  :         strm->avail_in = len;

  001b2	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  001b5	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  001b8	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 234  :         strm->next_in = (z_const Bytef *)buf;

  001bb	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  001be	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  001c1	89 02		 mov	 DWORD PTR [edx], eax

; 235  :         state->x.pos += len;

  001c3	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  001c6	33 d2		 xor	 edx, edx
  001c8	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  001cb	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  001ce	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001d1	13 c2		 adc	 eax, edx
  001d3	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  001d6	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  001d9	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 236  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  001dc	6a 00		 push	 0
  001de	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  001e1	50		 push	 eax
  001e2	e8 00 00 00 00	 call	 _gz_comp
  001e7	83 c4 08	 add	 esp, 8
  001ea	83 f8 ff	 cmp	 eax, -1
  001ed	75 04		 jne	 SHORT $LN3@gzwrite

; 237  :             return 0;

  001ef	33 c0		 xor	 eax, eax
  001f1	eb 03		 jmp	 SHORT $LN19@gzwrite
$LN3@gzwrite:

; 238  :     }
; 239  : 
; 240  :     /* input was all buffered or compressed (put will fit in int) */
; 241  :     return (int)put;

  001f3	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
$LN19@gzwrite:

; 242  : }

  001f6	8b e5		 mov	 esp, ebp
  001f8	5d		 pop	 ebp
  001f9	c2 0c 00	 ret	 12			; 0000000cH
_gzwrite@12 ENDP
PUBLIC	_gzprintf
; Function compile flags: /Odtp
;	COMDAT _gzprintf
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_va$ = -4						; size = 4
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_gzprintf PROC						; COMDAT

; 373  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 374  :     va_list va;
; 375  :     int ret;
; 376  : 
; 377  :     va_start(va, format);

  00006	8d 45 10	 lea	 eax, DWORD PTR _format$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR _va$[ebp], eax

; 378  :     ret = gzvprintf(file, format, va);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _va$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 0c	 mov	 edx, DWORD PTR _format$[ebp]
  00013	52		 push	 edx
  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _gzvprintf
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 379  :     va_end(va);

  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 380  :     return ret;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]

; 381  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_gzprintf ENDP
_TEXT	ENDS
PUBLIC	_gzputs@8
; Function compile flags: /Odtp
;	COMDAT _gzputs@8
_TEXT	SEGMENT
tv72 = -12						; size = 4
_ret$ = -8						; size = 4
_len$ = -4						; size = 4
_file$ = 8						; size = 4
_str$ = 12						; size = 4
_gzputs@8 PROC						; COMDAT

; 296  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 297  :     int ret;
; 298  :     unsigned len;
; 299  : 
; 300  :     /* write string */
; 301  :     len = (unsigned)strlen(str);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _strlen
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 302  :     ret = gzwrite(file, str, len);

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 0c	 mov	 edx, DWORD PTR _str$[ebp]
  0001c	52		 push	 edx
  0001d	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _gzwrite@12
  00026	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 303  :     return ret == 0 && len != 0 ? -1 : ret;

  00029	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0002d	75 0f		 jne	 SHORT $LN3@gzputs
  0002f	83 7d fc 00	 cmp	 DWORD PTR _len$[ebp], 0
  00033	74 09		 je	 SHORT $LN3@gzputs
  00035	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv72[ebp], -1
  0003c	eb 06		 jmp	 SHORT $LN4@gzputs
$LN3@gzputs:
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  00041	89 4d f4	 mov	 DWORD PTR tv72[ebp], ecx
$LN4@gzputs:
  00044	8b 45 f4	 mov	 eax, DWORD PTR tv72[ebp]

; 304  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_gzputs@8 ENDP
_TEXT	ENDS
PUBLIC	_gzputc@8
; Function compile flags: /Odtp
;	COMDAT _gzputc@8
_TEXT	SEGMENT
_state$ = -16						; size = 4
_buf$ = -9						; size = 1
_strm$ = -8						; size = 4
_have$ = -4						; size = 4
_file$ = 8						; size = 4
_c$ = 12						; size = 4
_gzputc@8 PROC						; COMDAT

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 249  :     unsigned have;
; 250  :     unsigned char buf[1];
; 251  :     gz_statep state;
; 252  :     z_streamp strm;
; 253  : 
; 254  :     /* get internal structure */
; 255  :     if (file == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0000a	75 08		 jne	 SHORT $LN9@gzputc

; 256  :         return -1;

  0000c	83 c8 ff	 or	 eax, -1
  0000f	e9 06 01 00 00	 jmp	 $LN10@gzputc
$LN9@gzputc:

; 257  :     state = (gz_statep)file;

  00014	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00017	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 258  :     strm = &(state->strm);

  0001a	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0001d	83 c1 64	 add	 ecx, 100		; 00000064H
  00020	89 4d f8	 mov	 DWORD PTR _strm$[ebp], ecx

; 259  : 
; 260  :     /* check that we're writing and that there's no error */
; 261  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00023	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00026	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0002d	75 09		 jne	 SHORT $LN7@gzputc
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00032	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00036	74 08		 je	 SHORT $LN8@gzputc
$LN7@gzputc:

; 262  :         return -1;

  00038	83 c8 ff	 or	 eax, -1
  0003b	e9 da 00 00 00	 jmp	 $LN10@gzputc
$LN8@gzputc:

; 263  : 
; 264  :     /* check for seek request */
; 265  :     if (state->seek) {

  00040	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00043	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  00047	74 2e		 je	 SHORT $LN6@gzputc

; 266  :         state->seek = 0;

  00049	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0004c	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 267  :         if (gz_zero(state, state->skip) == -1)

  00053	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00056	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00059	51		 push	 ecx
  0005a	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  0005d	52		 push	 edx
  0005e	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _gz_zero
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	83 f8 ff	 cmp	 eax, -1
  0006d	75 08		 jne	 SHORT $LN6@gzputc

; 268  :             return -1;

  0006f	83 c8 ff	 or	 eax, -1
  00072	e9 a3 00 00 00	 jmp	 $LN10@gzputc
$LN6@gzputc:

; 269  :     }
; 270  : 
; 271  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 272  :        initialized) */
; 273  :     if (state->size) {

  00077	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0007a	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  0007e	74 73		 je	 SHORT $LN4@gzputc

; 274  :         if (strm->avail_in == 0)

  00080	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  00083	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00087	75 0b		 jne	 SHORT $LN3@gzputc

; 275  :             strm->next_in = state->in;

  00089	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  0008c	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0008f	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00092	89 10		 mov	 DWORD PTR [eax], edx
$LN3@gzputc:

; 276  :         have = (unsigned)((strm->next_in + strm->avail_in) - state->in);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  00097	8b 08		 mov	 ecx, DWORD PTR [eax]
  00099	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  0009c	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0009f	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000a2	2b 48 24	 sub	 ecx, DWORD PTR [eax+36]
  000a5	89 4d fc	 mov	 DWORD PTR _have$[ebp], ecx

; 277  :         if (have < state->size) {

  000a8	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000ab	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  000ae	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  000b1	73 40		 jae	 SHORT $LN4@gzputc

; 278  :             state->in[have] = c;

  000b3	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000b6	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000b9	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  000bc	8a 45 0c	 mov	 al, BYTE PTR _c$[ebp]
  000bf	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 279  :             strm->avail_in++;

  000c2	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  000c5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000c8	83 c2 01	 add	 edx, 1
  000cb	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  000ce	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 280  :             state->x.pos++;

  000d1	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000d4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d7	83 c2 01	 add	 edx, 1
  000da	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000dd	83 d0 00	 adc	 eax, 0
  000e0	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000e3	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000e6	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 281  :             return c & 0xff;

  000e9	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  000ec	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000f1	eb 27		 jmp	 SHORT $LN10@gzputc
$LN4@gzputc:

; 282  :         }
; 283  :     }
; 284  : 
; 285  :     /* no room in buffer or not initialized, use gz_write() */
; 286  :     buf[0] = c;

  000f3	8a 55 0c	 mov	 dl, BYTE PTR _c$[ebp]
  000f6	88 55 f7	 mov	 BYTE PTR _buf$[ebp], dl

; 287  :     if (gzwrite(file, buf, 1) != 1)

  000f9	6a 01		 push	 1
  000fb	8d 45 f7	 lea	 eax, DWORD PTR _buf$[ebp]
  000fe	50		 push	 eax
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00102	51		 push	 ecx
  00103	e8 00 00 00 00	 call	 _gzwrite@12
  00108	83 f8 01	 cmp	 eax, 1
  0010b	74 05		 je	 SHORT $LN1@gzputc

; 288  :         return -1;

  0010d	83 c8 ff	 or	 eax, -1
  00110	eb 08		 jmp	 SHORT $LN10@gzputc
$LN1@gzputc:

; 289  :     return c & 0xff;

  00112	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  00115	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
$LN10@gzputc:

; 290  : }

  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c2 08 00	 ret	 8
_gzputc@8 ENDP
END
